#
# Код для решения задачи 26 (ЕГЭ по информатике)
#

# Имя файла с входными данными.
# Убедитесь, что файл с таким именем (например, '26.txt') 
# лежит в той же папке, что и этот скрипт.
filename = '27880.txt' 

try:
    with open(filename, 'r') as f:
        # Читаем первую строку: S (свободное место) и N (количество пользователей)
        S, N = map(int, f.readline().split())
        
        # Читаем все N размеров файлов в список
        files = []
        for _ in range(N):
            files.append(int(f.readline()))

    # --- Начало алгоритма ---

    # 1. Сортируем все файлы по возрастанию.
    # Чтобы взять максимальное_ число_ файлов, нам нужно брать самые маленькие.
    files.sort()

    saved_files_sum = 0
    saved_files_count = 0
    last_saved_file_index = -1 # Индекс последнего файла, который "влез"

    # 2. Жадный алгоритм: набираем самые маленькие файлы,
    # пока они помещаются в архив.
    for i in range(N):
        if saved_files_sum + files[i] <= S:
            saved_files_sum += files[i]
            saved_files_count += 1
            last_saved_file_index = i
        else:
            # Этот файл и все следующие (которые еще больше) уже не влезут
            break

    # Первый ответ — максимальное число пользователей.
    # Он у нас уже есть в 'saved_files_count'.
    print(saved_files_count)

    # 3. Ищем второй ответ: максимальный размер файла.
    # У нас есть 'saved_files_count' файлов. Сумма: 'saved_files_sum'.
    # Мы можем "выкинуть" самый большой из сохраненных (files[last_saved_file_index])
    # и попробовать "впихнуть" на его место файл побольше из тех, что мы не взяли.
    
    # Сумма всех, КРОМЕ самого большого из сохраненных
    sum_without_last = saved_files_sum - files[last_saved_file_index]
    
    # По умолчанию, самый большой файл, который мы можем взять -
    # это тот, который мы уже взяли (самый большой из "влезших").
    max_possible_file = files[last_saved_file_index]

    # Теперь идём по файлам, которые мы НЕ взяли 
    # (они начинаются с индекса last_saved_file_index + 1)
    for i in range(last_saved_file_index + 1, N):
        file_to_check = files[i]
        
        # Проверяем: если мы "выкинем" наш 'last_saved_file'
        # и добавим этот 'file_to_check', мы влезем в лимит S?
        if sum_without_last + file_to_check <= S:
            # Да, влезли. Значит, мы можем сохранить файл такого размера.
            # Так как мы идем по отсортированному списку,
            # мы просто перезаписываем 'max_possible_file'
            # Последнее значение и будет самым большим возможным.
            max_possible_file = file_to_check
        else:
            # Этот файл 'file_to_check' уже не влез.
            # А так как список отсортирован, все следующие (еще бОльшие)
            # файлы тем более не влезут. Можно останавливать проверку.
            break

    # Второй ответ - максимальный размер файла.
    print(max_possible_file)


except FileNotFoundError:
    print(f"Ошибка: Не могу найти файл с именем '{filename}'.")
    print("Пожалуйста, создайте этот файл или измените имя в коде.")
except Exception as e:
    print(f"Произошла ошибка: {e}")